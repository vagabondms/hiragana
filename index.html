<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>히라가나 공부</title>
    <style>
        :root {
            /* Colors */
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --text-primary: #333;
            --text-secondary: #666;
            --surface-white: white;
            --shadow-light: rgba(0, 0, 0, 0.2);
            --shadow-medium: rgba(0, 0, 0, 0.3);
            --shadow-dark: rgba(0, 0, 0, 0.5);

            /* Sizes */
            --card-width: 400px;
            --card-height: 300px;
            --card-padding: 60px 40px;
            --card-radius: 20px;
            --character-size: 120px;
            --hint-size: 18px;

            /* Animations */
            --flip-duration: 0.6s;
            --slide-duration: 0.3s;
            --hover-duration: 0.2s;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-user-drag: none;
            -webkit-touch-callout: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        /* Settings Button */
        .settings-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: var(--surface-white);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 15px var(--shadow-light);
            transition: transform var(--hover-duration), box-shadow var(--hover-duration);
            z-index: 100;
        }

        .settings-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px var(--shadow-medium);
        }

        .settings-btn:active {
            transform: scale(0.95);
        }

        /* Card System */
        .card-container {
            perspective: 1000px;
            cursor: pointer;
            position: relative;
            width: var(--card-width);
            height: var(--card-height);
        }

        .card {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform var(--flip-duration);
            transform-style: preserve-3d;
        }

        /* Card States */
        .card.flipped {
            transform: rotateY(180deg);
        }

        .card.flipped.slide-out-flipped {
            animation: card-exit var(--slide-duration) ease-in forwards;
        }

        .card.slide-in {
            animation: card-enter var(--slide-duration) ease-out forwards;
        }

        /* Animations */
        @keyframes card-exit {
            from {
                transform: translateX(0) rotateY(180deg);
                opacity: 1;
            }
            to {
                transform: translateX(100%) rotateY(180deg);
                opacity: 0;
            }
        }

        @keyframes card-enter {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Card Faces */
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            background: var(--surface-white);
            padding: var(--card-padding);
            border-radius: var(--card-radius);
            box-shadow: 0 20px 60px var(--shadow-medium);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .card-back {
            transform: rotateY(180deg);
        }

        /* Character Type Badge */
        .char-type-badge {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(102, 126, 234, 0.15);
            color: var(--bg-gradient-start);
            font-size: 14px;
            font-weight: 600;
            padding: 6px 12px;
            border-radius: 8px;
            border: 1.5px solid rgba(102, 126, 234, 0.3);
        }

        /* Content */
        .character {
            font-size: var(--character-size);
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 20px;
            white-space: nowrap;
        }

        .hint {
            font-size: var(--hint-size);
            color: var(--text-secondary);
            margin-top: 20px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root {
                --card-width: min(90vw, 350px);
                --card-height: 250px;
                --card-padding: 40px 20px;
                --character-size: 80px;
                --hint-size: 14px;
            }

            .settings-btn {
                top: 15px;
                right: 15px;
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
        }

        @media (max-width: 480px) {
            :root {
                --card-width: min(90vw, 300px);
                --card-height: 220px;
                --card-padding: 30px 15px;
                --character-size: 60px;
                --hint-size: 12px;
            }
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--shadow-dark);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--surface-white);
            padding: 40px;
            border-radius: var(--card-radius);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .modal-header h2 {
            font-size: 24px;
            color: var(--text-primary);
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: var(--text-secondary);
            line-height: 1;
            transition: color var(--hover-duration);
        }

        .close-btn:hover {
            color: var(--text-primary);
        }

        /* Type Selection */
        .type-selection-section {
            margin-bottom: 30px;
        }

        .type-selection-section h3 {
            font-size: 18px;
            color: var(--text-primary);
            margin-bottom: 15px;
        }

        .type-selection {
            display: flex;
            gap: 15px;
        }

        .type-checkbox {
            flex: 1;
            display: flex;
            align-items: center;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all var(--hover-duration);
        }

        .type-checkbox:hover {
            border-color: var(--bg-gradient-start);
            background: #f8f9ff;
        }

        .type-checkbox input[type="checkbox"] {
            margin-right: 8px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .type-checkbox.checked {
            border-color: var(--bg-gradient-start);
            background: var(--bg-gradient-start);
            color: var(--surface-white);
        }

        .type-checkbox label {
            cursor: pointer;
            font-weight: 500;
            font-size: 16px;
        }

        /* Character Selection */
        .character-selection-section h3 {
            font-size: 18px;
            color: var(--text-primary);
            margin-bottom: 15px;
        }

        .character-selection {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .character-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
        }

        .row-header {
            display: flex;
            align-items: center;
            min-width: 70px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: var(--surface-white);
            cursor: pointer;
            transition: all var(--hover-duration);
        }

        .row-header:hover {
            border-color: var(--bg-gradient-start);
            background: #f8f9ff;
        }

        .row-header.checked {
            border-color: var(--bg-gradient-start);
            background: var(--bg-gradient-start);
            color: var(--surface-white);
        }

        .row-header input[type="checkbox"] {
            margin-right: 6px;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .row-header label {
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
        }

        .character-list {
            display: grid;
            grid-template-columns: repeat(6, minmax(60px, 1fr));
            gap: 8px;
            flex: 1;
        }

        .character-checkbox {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: var(--surface-white);
            cursor: pointer;
            transition: all var(--hover-duration);
            font-size: 13px;
            justify-content: center;
        }

        .character-checkbox:hover {
            border-color: var(--bg-gradient-start);
            background: #f8f9ff;
        }

        .character-checkbox.checked {
            border-color: var(--bg-gradient-start);
            background: var(--bg-gradient-start);
            color: var(--surface-white);
        }

        .character-checkbox input[type="checkbox"] {
            margin-right: 5px;
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        .character-checkbox label {
            cursor: pointer;
            font-weight: 500;
        }

        .character-checkbox.empty {
            visibility: hidden;
            pointer-events: none;
        }

        .apply-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--surface-white);
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform var(--hover-duration);
        }

        .apply-btn:hover {
            transform: translateY(-2px);
        }

        .apply-btn:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <button class="settings-btn" id="settingsBtn">⚙️</button>

    <div class="card-container" id="cardContainer">
        <div class="card" id="card1">
            <div class="card-face card-front">
                <div class="char-type-badge" id="badge1"></div>
                <div class="character" id="characterFront1">準備中...</div>
                <div class="hint">스페이스바 또는 클릭/터치하여 시작</div>
            </div>
            <div class="card-face card-back">
                <div class="character" id="characterBack1"></div>
                <div class="hint">다시 클릭/터치하여 다음 문제</div>
            </div>
        </div>
        <div class="card" id="card2" style="display: none;">
            <div class="card-face card-front">
                <div class="char-type-badge" id="badge2"></div>
                <div class="character" id="characterFront2"></div>
                <div class="hint">스페이스바 또는 클릭/터치하여 시작</div>
            </div>
            <div class="card-face card-back">
                <div class="character" id="characterBack2"></div>
                <div class="hint">다시 클릭/터치하여 다음 문제</div>
            </div>
        </div>
    </div>

    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>학습 설정</h2>
                <button class="close-btn" id="closeModal">&times;</button>
            </div>

            <div class="type-selection-section">
                <h3>문자 체계 선택</h3>
                <div class="type-selection" id="typeSelection"></div>
            </div>

            <div class="character-selection-section">
                <h3>학습할 글자 선택</h3>
                <div class="character-selection" id="characterSelection"></div>
            </div>

            <button class="apply-btn" id="applyBtn">적용</button>
        </div>
    </div>

    <script>
        // 히라가나 데이터 (행별 분류)
        const hiraganaData = {
            A: [
                { hiragana: 'あ', korean: '아' },
                { hiragana: 'い', korean: '이' },
                { hiragana: 'う', korean: '우' },
                { hiragana: 'え', korean: '에' },
                { hiragana: 'お', korean: '오' }
            ],
            K: [
                { hiragana: 'か', korean: '카' },
                { hiragana: 'き', korean: '키' },
                { hiragana: 'く', korean: '쿠' },
                { hiragana: 'け', korean: '케' },
                { hiragana: 'こ', korean: '코' }
            ],
            S: [
                { hiragana: 'さ', korean: '사' },
                { hiragana: 'し', korean: '시' },
                { hiragana: 'す', korean: '스' },
                { hiragana: 'せ', korean: '세' },
                { hiragana: 'そ', korean: '소' }
            ],
            T: [
                { hiragana: 'た', korean: '타' },
                { hiragana: 'ち', korean: '치' },
                { hiragana: 'つ', korean: '츠' },
                { hiragana: 'て', korean: '테' },
                { hiragana: 'と', korean: '토' }
            ],
            N: [
                { hiragana: 'な', korean: '나' },
                { hiragana: 'に', korean: '니' },
                { hiragana: 'ぬ', korean: '누' },
                { hiragana: 'ね', korean: '네' },
                { hiragana: 'の', korean: '노' }
            ],
            H: [
                { hiragana: 'は', korean: '하' },
                { hiragana: 'ひ', korean: '히' },
                { hiragana: 'ふ', korean: '후' },
                { hiragana: 'へ', korean: '헤' },
                { hiragana: 'ほ', korean: '호' }
            ],
            M: [
                { hiragana: 'ま', korean: '마' },
                { hiragana: 'み', korean: '미' },
                { hiragana: 'む', korean: '무' },
                { hiragana: 'め', korean: '메' },
                { hiragana: 'も', korean: '모' }
            ],
            Y: [
                { hiragana: 'や', korean: '야' },
                { hiragana: 'ゆ', korean: '유' },
                { hiragana: 'よ', korean: '요' }
            ],
            R: [
                { hiragana: 'ら', korean: '라' },
                { hiragana: 'り', korean: '리' },
                { hiragana: 'る', korean: '루' },
                { hiragana: 'れ', korean: '레' },
                { hiragana: 'ろ', korean: '로' }
            ],
            W: [
                { hiragana: 'わ', korean: '와' },
                { hiragana: 'を', korean: '오(을)' },
                { hiragana: 'ん', korean: 'ㄴ' }
            ]
        };

        // 가타카나 데이터 (행별 분류)
        const katakanaData = {
            A: [
                { katakana: 'ア', korean: '아' },
                { katakana: 'イ', korean: '이' },
                { katakana: 'ウ', korean: '우' },
                { katakana: 'エ', korean: '에' },
                { katakana: 'オ', korean: '오' }
            ],
            K: [
                { katakana: 'カ', korean: '카' },
                { katakana: 'キ', korean: '키' },
                { katakana: 'ク', korean: '쿠' },
                { katakana: 'ケ', korean: '케' },
                { katakana: 'コ', korean: '코' }
            ],
            S: [
                { katakana: 'サ', korean: '사' },
                { katakana: 'シ', korean: '시' },
                { katakana: 'ス', korean: '스' },
                { katakana: 'セ', korean: '세' },
                { katakana: 'ソ', korean: '소' }
            ],
            T: [
                { katakana: 'タ', korean: '타' },
                { katakana: 'チ', korean: '치' },
                { katakana: 'ツ', korean: '츠' },
                { katakana: 'テ', korean: '테' },
                { katakana: 'ト', korean: '토' }
            ],
            N: [
                { katakana: 'ナ', korean: '나' },
                { katakana: 'ニ', korean: '니' },
                { katakana: 'ヌ', korean: '누' },
                { katakana: 'ネ', korean: '네' },
                { katakana: 'ノ', korean: '노' }
            ],
            H: [
                { katakana: 'ハ', korean: '하' },
                { katakana: 'ヒ', korean: '히' },
                { katakana: 'フ', korean: '후' },
                { katakana: 'ヘ', korean: '헤' },
                { katakana: 'ホ', korean: '호' }
            ],
            M: [
                { katakana: 'マ', korean: '마' },
                { katakana: 'ミ', korean: '미' },
                { katakana: 'ム', korean: '무' },
                { katakana: 'メ', korean: '메' },
                { katakana: 'モ', korean: '모' }
            ],
            Y: [
                { katakana: 'ヤ', korean: '야' },
                { katakana: 'ユ', korean: '유' },
                { katakana: 'ヨ', korean: '요' }
            ],
            R: [
                { katakana: 'ラ', korean: '라' },
                { katakana: 'リ', korean: '리' },
                { katakana: 'ル', korean: '루' },
                { katakana: 'レ', korean: '레' },
                { katakana: 'ロ', korean: '로' }
            ],
            W: [
                { katakana: 'ワ', korean: '와' },
                { katakana: 'ヲ', korean: '오(을)' },
                { katakana: 'ン', korean: 'ㄴ' }
            ]
        };

        // 로마자 발음 매핑 (null은 빈 칸)
        const romajiMap = {
            A: ['a', 'i', 'u', 'e', 'o'],
            K: ['ka', 'ki', 'ku', 'ke', 'ko'],
            S: ['sa', 'si', 'su', 'se', 'so'],
            T: ['ta', 'chi', 'tsu', 'te', 'to'],
            N: ['na', 'ni', 'nu', 'ne', 'no'],
            H: ['ha', 'hi', 'fu', 'he', 'ho'],
            M: ['ma', 'mi', 'mu', 'me', 'mo'],
            Y: ['ya', null, 'yu', null, 'yo'],
            R: ['ra', 'ri', 'ru', 're', 'ro'],
            W: ['wa', null, null, null, 'wo']
        };

        // n(ん)은 W행 이후 별도로 표시
        const extraChars = {
            W: { index: 5, romaji: 'n' }  // 6번째 위치에 n 추가
        };

        // 상태 관리
        let state = 'initial'; // initial, korean, hiragana
        let currentChar = null;
        let selectedRows = ['A', 'K', 'S', 'T', 'N', 'H', 'M', 'Y', 'R', 'W'];
        let selectedTypes = ['hiragana']; // 'hiragana', 'katakana' 배열
        let selectedCharacters = {}; // 개별 글자 선택 상태
        let availableChars = [];
        let remainingChars = []; // 남은 글자들 (카드 덱)
        let consumedChars = []; // 사용된 글자들
        let activeCard = 1; // 현재 활성화된 카드 (1 또는 2)
        let isAnimating = false; // 애니메이션 진행 중 플래그
        let card1State = 'front'; // 'front' 또는 'back'
        let card2State = 'front'; // 'front' 또는 'back'

        // DOM 요소
        const card1El = document.getElementById('card1');
        const card2El = document.getElementById('card2');
        const characterFront1El = document.getElementById('characterFront1');
        const characterBack1El = document.getElementById('characterBack1');
        const characterFront2El = document.getElementById('characterFront2');
        const characterBack2El = document.getElementById('characterBack2');
        const badge1El = document.getElementById('badge1');
        const badge2El = document.getElementById('badge2');
        const cardContainerEl = document.getElementById('cardContainer');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const closeModalBtn = document.getElementById('closeModal');
        const applyBtn = document.getElementById('applyBtn');
        const typeSelectionEl = document.getElementById('typeSelection');
        const characterSelectionEl = document.getElementById('characterSelection');

        // 현재 활성 카드의 DOM 요소 가져오기
        function getActiveCardElements() {
            if (activeCard === 1) {
                return {
                    cardEl: card1El,
                    frontEl: characterFront1El,
                    backEl: characterBack1El,
                    badgeEl: badge1El
                };
            } else {
                return {
                    cardEl: card2El,
                    frontEl: characterFront2El,
                    backEl: characterBack2El,
                    badgeEl: badge2El
                };
            }
        }

        // 비활성 카드의 DOM 요소 가져오기
        function getInactiveCardElements() {
            if (activeCard === 1) {
                return {
                    cardEl: card2El,
                    frontEl: characterFront2El,
                    backEl: characterBack2El,
                    badgeEl: badge2El
                };
            } else {
                return {
                    cardEl: card1El,
                    frontEl: characterFront1El,
                    backEl: characterBack1El,
                    badgeEl: badge1El
                };
            }
        }

        // selectedCharacters 초기화 (모든 글자 선택 상태)
        function initializeSelectedCharacters() {
            const result = {};
            ['hiragana', 'katakana'].forEach(type => {
                result[type] = {};
                Object.keys(romajiMap).forEach(row => {
                    // null이 아닌 항목만 true로 초기화
                    result[type][row] = romajiMap[row].map(r => r !== null);

                    // W행의 경우 n 추가
                    if (row === 'W' && extraChars[row]) {
                        result[type][row].push(true);
                    }
                });
            });
            return result;
        }

        // 로컬 스토리지에서 설정 불러오기
        function loadSettings() {
            const savedRows = localStorage.getItem('selectedRows');
            if (savedRows) {
                selectedRows = JSON.parse(savedRows);
            }

            const savedTypes = localStorage.getItem('selectedTypes');
            if (savedTypes) {
                selectedTypes = JSON.parse(savedTypes);
            }

            const savedCharacters = localStorage.getItem('selectedCharacters');
            if (savedCharacters) {
                selectedCharacters = JSON.parse(savedCharacters);
            } else {
                selectedCharacters = initializeSelectedCharacters();
            }

            updateAvailableChars();

            // 카드 덱 초기화
            remainingChars = [...availableChars];
            consumedChars = [];
        }

        // 사용 가능한 글자 업데이트
        function updateAvailableChars() {
            availableChars = [];

            Object.keys(romajiMap).forEach(row => {
                // 히라가나 추가
                if (selectedTypes.includes('hiragana') && hiraganaData[row] && selectedCharacters.hiragana[row]) {
                    hiraganaData[row].forEach((char, index) => {
                        if (selectedCharacters.hiragana[row][index]) {
                            availableChars.push({
                                ...char,
                                type: 'hiragana',
                                japanese: char.hiragana
                            });
                        }
                    });
                }

                // 가타카나 추가
                if (selectedTypes.includes('katakana') && katakanaData[row] && selectedCharacters.katakana[row]) {
                    katakanaData[row].forEach((char, index) => {
                        if (selectedCharacters.katakana[row][index]) {
                            availableChars.push({
                                ...char,
                                type: 'katakana',
                                japanese: char.katakana
                            });
                        }
                    });
                }
            });
        }

        // 랜덤 글자 선택 (카드 덱 방식 - 한 번 나온 글자는 모두 소비할 때까지 제외)
        function getRandomChar() {
            if (availableChars.length === 0) return null;

            // 남은 글자가 없으면 덱을 다시 채움 (리셔플)
            if (remainingChars.length === 0) {
                remainingChars = [...availableChars];
                consumedChars = [];
            }

            // 남은 글자 중에서 랜덤 선택
            const randomIndex = Math.floor(Math.random() * remainingChars.length);
            const selectedChar = remainingChars[randomIndex];

            // 선택된 글자를 남은 목록에서 제거 (카드를 버림)
            remainingChars.splice(randomIndex, 1);

            // 사용된 목록에 추가
            consumedChars.push(selectedChar);

            return selectedChar;
        }

        // 각 카드의 상태 가져오기/설정하기
        function getCardState(cardNum) {
            return cardNum === 1 ? card1State : card2State;
        }

        function setCardState(cardNum, newState) {
            if (cardNum === 1) {
                card1State = newState;
            } else {
                card2State = newState;
            }
        }

        // 다음 단계로 진행
        function nextStep() {
            // 애니메이션 중에는 입력 무시
            if (isAnimating) return;

            const active = getActiveCardElements();
            const activeCardNum = activeCard;

            if (state === 'initial') {
                // 한국어 표시 (앞면)
                currentChar = getRandomChar();
                if (!currentChar) {
                    active.frontEl.textContent = '행을 선택해주세요';
                    active.badgeEl.textContent = '';
                    return;
                }
                active.frontEl.textContent = currentChar.korean;
                active.backEl.textContent = currentChar.japanese;
                active.badgeEl.textContent = currentChar.type === 'hiragana' ? '히' : '가';
                active.cardEl.classList.remove('flipped', 'slide-out-flipped', 'slide-in');
                setCardState(activeCardNum, 'front');
                state = 'korean';
            } else if (state === 'korean') {
                // 카드 뒤집기 - 히라가나 표시 (뒷면)
                isAnimating = true;
                active.cardEl.classList.add('flipped');
                setCardState(activeCardNum, 'back');
                state = 'hiragana';

                // 플립 애니메이션 완료 후
                setTimeout(() => {
                    isAnimating = false;
                }, 600);
            } else if (state === 'hiragana') {
                // 다음 글자로 - 카드 슬라이드 애니메이션
                isAnimating = true;
                const inactive = getInactiveCardElements();
                const inactiveCardNum = activeCard === 1 ? 2 : 1;

                // 1. 새 글자 가져오기
                currentChar = getRandomChar();
                if (!currentChar) {
                    active.frontEl.textContent = '행을 선택해주세요';
                    active.badgeEl.textContent = '';
                    active.cardEl.classList.remove('flipped', 'slide-out-flipped', 'slide-in');
                    setCardState(activeCardNum, 'front');
                    state = 'initial';
                    isAnimating = false;
                    return;
                }

                // 2. 비활성 카드를 앞면 상태로 설정하고 새 데이터 넣기 (한국어 보이게)
                inactive.frontEl.textContent = currentChar.korean;
                inactive.backEl.textContent = currentChar.japanese;
                inactive.badgeEl.textContent = currentChar.type === 'hiragana' ? '히' : '가';
                inactive.cardEl.classList.remove('flipped', 'slide-out-flipped', 'slide-in');
                setCardState(inactiveCardNum, 'front');
                inactive.cardEl.style.display = 'block';

                // 3. 현재 카드를 flipped 상태 유지하면서 슬라이드 아웃 (일본어 보이면서 나가기)
                // flipped 클래스를 유지한 채로 slide-out-flipped 추가
                active.cardEl.classList.add('slide-out-flipped');

                // 5. 동시에 새 카드 슬라이드 인 (한국어 보이면서 들어오기)
                requestAnimationFrame(() => {
                    inactive.cardEl.classList.add('slide-in');
                });

                // 6. 애니메이션 완료 후 정리
                setTimeout(() => {
                    active.cardEl.style.display = 'none';
                    active.cardEl.classList.remove('flipped', 'slide-out-flipped');
                    setCardState(activeCardNum, 'front');
                    inactive.cardEl.classList.remove('slide-in');
                    activeCard = inactiveCardNum;
                    state = 'korean';
                    isAnimating = false;
                }, 300);
            }
        }

        // 설정 모달 렌더링
        function renderSettings() {
            // 문자 체계 선택 렌더링
            typeSelectionEl.innerHTML = '';
            const types = [
                { id: 'hiragana', label: '히라가나' },
                { id: 'katakana', label: '가타카나' }
            ];

            types.forEach(type => {
                const isChecked = selectedTypes.includes(type.id);
                const div = document.createElement('div');
                div.className = `type-checkbox ${isChecked ? 'checked' : ''}`;
                div.innerHTML = `
                    <input type="checkbox" id="type-${type.id}" ${isChecked ? 'checked' : ''}>
                    <label for="type-${type.id}">${type.label}</label>
                `;

                const checkbox = div.querySelector('input');
                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        div.classList.add('checked');
                    } else {
                        div.classList.remove('checked');
                    }
                });

                typeSelectionEl.appendChild(div);
            });

            // 개별 글자 선택 렌더링
            characterSelectionEl.innerHTML = '';
            Object.keys(romajiMap).forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'character-row';

                // 행 헤더 (행 전체 선택 체크박스)
                const rowHeaderDiv = document.createElement('div');
                // null이 아닌 항목만 검사
                const allSelected = selectedCharacters.hiragana[row].every((v, i) =>
                    romajiMap[row][i] === null || v
                ) && selectedCharacters.katakana[row].every((v, i) =>
                    romajiMap[row][i] === null || v
                );
                rowHeaderDiv.className = `row-header ${allSelected ? 'checked' : ''}`;
                rowHeaderDiv.innerHTML = `
                    <input type="checkbox" id="row-header-${row}" ${allSelected ? 'checked' : ''}>
                    <label for="row-header-${row}">${row}행</label>
                `;

                const rowHeaderCheckbox = rowHeaderDiv.querySelector('input');
                rowHeaderCheckbox.addEventListener('change', (e) => {
                    const checked = e.target.checked;
                    // 행의 모든 글자 선택/해제 (null인 항목은 그대로 유지)
                    selectedCharacters.hiragana[row] = selectedCharacters.hiragana[row].map((v, i) =>
                        romajiMap[row][i] === null ? false : checked
                    );
                    selectedCharacters.katakana[row] = selectedCharacters.katakana[row].map((v, i) =>
                        romajiMap[row][i] === null ? false : checked
                    );

                    // W행의 n도 업데이트
                    if (row === 'W') {
                        selectedCharacters.hiragana[row][5] = checked;
                        selectedCharacters.katakana[row][5] = checked;
                    }

                    // UI 업데이트
                    if (checked) {
                        rowHeaderDiv.classList.add('checked');
                    } else {
                        rowHeaderDiv.classList.remove('checked');
                    }

                    // 개별 글자 체크박스들도 업데이트
                    const charCheckboxes = rowDiv.querySelectorAll('.character-checkbox:not(.empty) input');
                    charCheckboxes.forEach(cb => {
                        cb.checked = checked;
                        if (checked) {
                            cb.parentElement.classList.add('checked');
                        } else {
                            cb.parentElement.classList.remove('checked');
                        }
                    });
                });

                // 개별 글자 리스트
                const charListDiv = document.createElement('div');
                charListDiv.className = 'character-list';

                // 5개 고정 칸 + W행의 경우 n 추가
                const totalSlots = row === 'W' ? 6 : 5;
                let dataIndex = 0;

                for (let slotIndex = 0; slotIndex < totalSlots; slotIndex++) {
                    const charDiv = document.createElement('div');

                    // W행의 6번째 슬롯은 n
                    if (row === 'W' && slotIndex === 5) {
                        const isChecked = selectedCharacters.hiragana[row][5] &&
                                          selectedCharacters.katakana[row][5];
                        charDiv.className = `character-checkbox ${isChecked ? 'checked' : ''}`;
                        charDiv.innerHTML = `
                            <input type="checkbox" id="char-${row}-5" ${isChecked ? 'checked' : ''}>
                            <label for="char-${row}-5">n</label>
                        `;

                        const charCheckbox = charDiv.querySelector('input');
                        charCheckbox.addEventListener('change', (e) => {
                            const checked = e.target.checked;
                            selectedCharacters.hiragana[row][5] = checked;
                            selectedCharacters.katakana[row][5] = checked;

                            if (checked) {
                                charDiv.classList.add('checked');
                            } else {
                                charDiv.classList.remove('checked');
                            }

                            // 행 전체 선택 상태 업데이트
                            const allChecked = selectedCharacters.hiragana[row].every((v, i) =>
                                romajiMap[row][i] === null || v
                            ) && selectedCharacters.katakana[row].every((v, i) =>
                                romajiMap[row][i] === null || v
                            );
                            rowHeaderCheckbox.checked = allChecked;
                            if (allChecked) {
                                rowHeaderDiv.classList.add('checked');
                            } else {
                                rowHeaderDiv.classList.remove('checked');
                            }
                        });
                    } else if (romajiMap[row][slotIndex] === null) {
                        // 빈 칸
                        charDiv.className = 'character-checkbox empty';
                        charDiv.innerHTML = '<span></span>';
                    } else {
                        // 일반 글자
                        const romaji = romajiMap[row][slotIndex];
                        const isChecked = selectedCharacters.hiragana[row][dataIndex] &&
                                          selectedCharacters.katakana[row][dataIndex];
                        charDiv.className = `character-checkbox ${isChecked ? 'checked' : ''}`;
                        charDiv.innerHTML = `
                            <input type="checkbox" id="char-${row}-${dataIndex}" ${isChecked ? 'checked' : ''}>
                            <label for="char-${row}-${dataIndex}">${romaji}</label>
                        `;

                        const currentDataIndex = dataIndex;
                        const charCheckbox = charDiv.querySelector('input');
                        charCheckbox.addEventListener('change', (e) => {
                            const checked = e.target.checked;
                            selectedCharacters.hiragana[row][currentDataIndex] = checked;
                            selectedCharacters.katakana[row][currentDataIndex] = checked;

                            if (checked) {
                                charDiv.classList.add('checked');
                            } else {
                                charDiv.classList.remove('checked');
                            }

                            // 행 전체 선택 상태 업데이트
                            const allChecked = selectedCharacters.hiragana[row].every((v, i) =>
                                romajiMap[row][i] === null || v
                            ) && selectedCharacters.katakana[row].every((v, i) =>
                                romajiMap[row][i] === null || v
                            );
                            rowHeaderCheckbox.checked = allChecked;
                            if (allChecked) {
                                rowHeaderDiv.classList.add('checked');
                            } else {
                                rowHeaderDiv.classList.remove('checked');
                            }
                        });
                    }

                    charListDiv.appendChild(charDiv);

                    // null이 아닌 경우에만 dataIndex 증가
                    if (romajiMap[row][slotIndex] !== null) {
                        dataIndex++;
                    }
                }

                rowDiv.appendChild(rowHeaderDiv);
                rowDiv.appendChild(charListDiv);
                characterSelectionEl.appendChild(rowDiv);
            });
        }

        // 설정 적용
        function applySettings() {
            // 문자 체계 선택 수집
            selectedTypes = [];
            document.querySelectorAll('.type-checkbox input[type="checkbox"]:checked').forEach(checkbox => {
                const type = checkbox.id.replace('type-', '');
                selectedTypes.push(type);
            });

            if (selectedTypes.length === 0) {
                alert('최소 하나의 문자 체계를 선택해주세요!');
                return;
            }

            // 최소 1개 글자 선택 검증
            let hasSelectedChar = false;
            Object.keys(selectedCharacters.hiragana).forEach(row => {
                if (selectedCharacters.hiragana[row].some(v => v) || selectedCharacters.katakana[row].some(v => v)) {
                    hasSelectedChar = true;
                }
            });

            if (!hasSelectedChar) {
                alert('최소 하나의 글자를 선택해주세요!');
                return;
            }

            // localStorage에 저장
            localStorage.setItem('selectedTypes', JSON.stringify(selectedTypes));
            localStorage.setItem('selectedCharacters', JSON.stringify(selectedCharacters));
            updateAvailableChars();

            // 카드 덱 리셋
            remainingChars = [...availableChars];
            consumedChars = [];

            settingsModal.classList.remove('active');

            // 상태 초기화
            state = 'initial';
            activeCard = 1;
            card1State = 'front';
            card2State = 'front';
            isAnimating = false;
            card1El.style.display = 'block';
            card2El.style.display = 'none';
            characterFront1El.textContent = '準備中...';
            badge1El.textContent = '';
            card1El.classList.remove('flipped', 'slide-out-flipped', 'slide-in');
            card2El.classList.remove('flipped', 'slide-out-flipped', 'slide-in');
        }

        // 이벤트 리스너
        const openSettings = (e) => {
            e.stopPropagation();
            e.preventDefault();
            renderSettings();
            settingsModal.classList.add('active');
        };

        settingsBtn.addEventListener('click', openSettings);
        settingsBtn.addEventListener('touchend', openSettings);

        const closeSettings = () => {
            settingsModal.classList.remove('active');
        };

        closeModalBtn.addEventListener('click', closeSettings);
        closeModalBtn.addEventListener('touchend', closeSettings);

        const closeOnBackdrop = (e) => {
            if (e.target === settingsModal) {
                settingsModal.classList.remove('active');
            }
        };

        settingsModal.addEventListener('click', closeOnBackdrop);
        settingsModal.addEventListener('touchend', closeOnBackdrop);

        applyBtn.addEventListener('click', applySettings);
        applyBtn.addEventListener('touchend', applySettings);

        // 스페이스바 이벤트
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                nextStep();
            }
        });

        // 클릭 및 터치 이벤트
        const handleNext = (e) => {
            e.preventDefault();
            nextStep();
        };

        cardContainerEl.addEventListener('click', handleNext);
        cardContainerEl.addEventListener('touchend', handleNext);

        // 초기화
        loadSettings();
    </script>
</body>
</html>
